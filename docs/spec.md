# Tetris 멀티유저 게임 상세 설계 문서

## 1. 개요
### 1.1 프로젝트 목적
이 프로젝트는 Rocky Linux 서버를 기반으로 한 멀티유저 Tetris 게임을 개발하는 것을 목표로 합니다. 각 플레이어는 독립적으로 Tetris 게임을 플레이하지만, 실시간으로 다른 플레이어의 점수와 화면 상태를 공유하며 경쟁합니다. 게임은 점수 경쟁 중심으로, 플레이어 간 상호작용(예: 서로의 게임에 영향을 주는 요소)은 없습니다. 서버는 Rocky Linux에서 실행되며, 클라이언트는 웹 브라우저를 통해 접근 가능하도록 설계하여 접근성을 높입니다.

### 1.2 주요 기능 요약
- 플레이어 이름 입력 후 즉시 게임 화면 진입.
- 언제든지 다른 유저가 참여 가능 (실시간 접속/퇴장 지원).
- 실시간으로 다른 플레이어의 게임 화면을 왼쪽 빈 공간에 표시 (점수 높은 순으로 갱신).
- Top 순위 외 플레이어 정보는 별도 대시보드에 표시.
- 각 플레이어의 게임은 독립적이며, 점수 경쟁만 존재.

### 1.3 대상 환경
- **서버**: Rocky Linux (버전 9.x 추천, RHEL 호환성 활용).
- **클라이언트**: 웹 브라우저 (Chrome, Firefox 등, HTML5 Canvas 지원).
- **네트워크**: 실시간 통신을 위해 WebSocket 프로토콜 사용.
- **예상 사용자 수**: 초기 10~50명 동시 접속 지원, 확장 가능.

### 1.4 가정 및 제약
- 게임은 웹 기반으로 구현 (터미널 기반이 아닌 GUI Tetris).
- 화면 공유는 실시간이지만, 네트워크 지연을 고려한 간단한 상태 업데이트 (전체 화면 이미지가 아닌 텍스트/벡터 기반 표현).
- 보안: 간단한 세션 관리, DDoS 방지 등 기본 수준.
- Rocky Linux의 패키지 관리자 (dnf)를 활용하여 필요한 라이브러리 설치.

## 2. 요구사항 분석
### 2.1 기능적 요구사항
- **사용자 온보딩**:
  - 플레이어 이름 입력: 간단한 입력 폼 (중복 이름 허용 또는 자동 ID 부여).
  - 입력 후 즉시 게임 화면 진입.
- **참여 및 퇴장**:
  - 언제든지 참여 가능: 서버에 연결 시 자동 등록.
  - 퇴장 시 자동 제거 및 실시간 업데이트.
- **실시간 화면 공유**:
  - 메인 게임 화면 왼쪽에 다른 플레이어의 미니 화면 표시.
  - 표시 기준: 점수 높은 순 (Top N, 예: Top 5).
  - 갱신: 실시간 (초당 1~5회 업데이트).
- **대시보드**:
  - Top 순위 외 플레이어 정보 표시 (이름, 점수, 상태 등).
  - 별도 페이지 또는 모달/사이드바로 접근.
- **게임 로직**:
  - 표준 Tetris 규칙: 블록 생성, 이동, 회전, 라인 클리어, 점수 계산.
  - 멀티유저: 각 플레이어 독립 게임 인스턴스, 상호 영향 없음.
  - 점수 경쟁: 실시간 랭킹 업데이트.

### 2.2 비기능적 요구사항
- **성능**: 동시 50명 접속 시 지연 < 200ms.
- **확장성**: 서버 클러스터링 지원 (미래 확장).
- **보안**: 입력 검증 (XSS 방지), 세션 기반 인증.
- **접근성**: 모바일 브라우저 지원 (반응형 디자인).
- **로그 및 모니터링**: 게임 이벤트 로그 저장 (Rocky Linux의 systemd 활용).

## 3. 시스템 아키텍처
### 3.1 전체 아키텍처 다이어그램 (텍스트 기반 표현)
```
[클라이언트 (웹 브라우저)] <-> [인터넷] <-> [Rocky Linux 서버]
  - HTML/JS/Canvas (게임 UI)        - Node.js 또는 Python Flask (백엔드)
  - WebSocket (실시간 통신)          - WebSocket 서버 (Socket.io 또는 ws)
                                     - 데이터베이스 (SQLite 또는 Redis for 실시간)
                                     - Tetris 로직 모듈
```

- **클라이언트-서버 모델**: 클라이언트는 게임 로직을 로컬에서 처리하고, 서버는 상태 공유만 담당.
- **실시간 통신**: WebSocket을 통해 플레이어 상태 (점수, 화면 그리드)를 브로드캐스트.
- **서버 스택**:
  - OS: Rocky Linux.
  - 백엔드: Node.js (Express + Socket.io) 또는 Python (Flask + Flask-SocketIO).
  - 데이터 저장: Redis (실시간 상태) + SQLite (영구 로그).
  - 웹 서버: Nginx (정적 파일 호스팅 및 리버스 프록시).

### 3.2 컴포넌트 상세
- **클라이언트 컴포넌트**:
  - **로그인 모듈**: 이름 입력 폼 → 세션 생성 → 게임 화면 전환.
  - **게임 엔진**: JavaScript로 구현된 Tetris 로직 (Canvas로 그리기) 또는 더 좋은 방법?.
    - 그리드: 10x20 셀 (표준 Tetris).
    - 블록: 7종 (I, O, T, S, Z, J, L).
    - 입력: 키보드 (화살표, 스페이스 등).
  - **실시간 뷰어**: 왼쪽 패널에 Top 플레이어의 미니 그리드 표시 (Canvas 스케일링).
  - **대시보드**: 버튼 클릭 시 별도 팝업 또는 페이지에 전체 플레이어 목록 표시 (이름, 점수, 접속 시간).
- **서버 컴포넌트**:
  - **인증 모듈**: 이름 입력 시 유니크 ID 생성 (UUID 사용).
  - **상태 관리**: 각 플레이어의 상태 저장 (점수, 그리드 상태: 2D 배열로 압축).
  - **브로드캐스트 모듈**: WebSocket으로 모든 클라이언트에 상태 업데이트 푸시.
    - 이벤트: 'update_scores', 'update_screens'.
  - **랭킹 로직**: 점수 기준 정렬 (Top N 추출).
  - **대시보드 API**: GET 엔드포인트로 전체 플레이어 데이터 제공.

### 3.3 데이터 흐름
1. 클라이언트 → 서버: 이름 입력 → 세션 생성.
2. 클라이언트: 로컬 Tetris 시작, 주기적 상태 업데이트 서버로 전송 (점수, 그리드).
3. 서버: 모든 플레이어 상태 수집 → 랭킹 계산 → 브로드캐스트.
4. 클라이언트: 수신된 데이터로 왼쪽 패널 업데이트.
5. 대시보드 요청 시: 서버 → 클라이언트: 전체 데이터 전송.

## 4. 데이터 구조
### 4.1 주요 데이터 모델
- **Player**:
  - id: string (UUID).
  - name: string.
  - score: integer.
  - grid: array[20][10] (0: 빈 셀, 1-7: 블록 타입).
  - status: enum ('playing', 'gameover').
  - join_time: timestamp.
- **Ranking**:
  - top_players: array of Player (점수 내림차순, Top 5).
  - all_players: array of Player (대시보드용).
- **Event Payload** (WebSocket):
  - type: string (e.g., 'update').
  - data: { players: array<Player> }.

### 4.2 저장소
- 실시간: Redis (키: 'players', 값: JSON 직렬화).
- 영구: SQLite (테이블: players_log, columns: id, name, score, timestamp).

## 5. UI/UX 설계
### 5.1 화면 레이아웃
- **로그인 화면**: 중앙 입력 폼 (이름) + "시작" 버튼.
- **메인 게임 화면**:
  - 중앙: 내 Tetris 그리드 (400x800px Canvas).
  - 왼쪽: Top 플레이어 미니 화면 (100x200px 각, 수직 스택, Top 5).
    - 각 미니 화면: 이름 + 점수 + 축소 그리드.
  - 오른쪽: 내 점수, 다음 블록 미리보기.
  - 하단: 대시보드 버튼.
- **대시보드 화면**: 테이블 형식 (이름 | 점수 | 상태 | 접속 시간).
  - 정렬 가능 (점수 기준 기본).

### 5.2 사용자 흐름
1. 브라우저 열기 → 로그인 → 게임 시작.
2. 플레이 중: 실시간 업데이트 수신.
3. 게임 오버: 점수 제출 → 랭킹 반영.
4. 대시보드: 언제든 접근 가능.

## 6. 구현 계획
### 6.1 개발 스택
- **서버 설치 (Rocky Linux)**:
  - dnf install nodejs python3 nginx redis sqlite.
  - Node.js: npm install express socket.io.
  - Python 대안: pip install flask flask-socketio.
- **클라이언트**: HTML/JS, 라이브러리: Socket.io-client.
- **테스트**: 로컬 개발 후 서버 배포.

### 6.2 단계별 구현
1. 기본 Tetris 엔진 구현 (클라이언트 JS).
2. WebSocket 통합: 상태 공유.
3. 랭킹 및 화면 표시 로직.
4. 대시보드 추가.
5. 테스트: 다중 브라우저로 동시 접속 확인.

### 6.3 잠재적 이슈 및 해결
- 네트워크 지연: 그리드 압축 (JSON.stringify 최적화).
- 스케일링: Redis 클러스터.
- 보안: HTTPS 강제 (Let's Encrypt 사용).
- Rocky Linux 특성: SELinux 설정 (포트 개방 시 주의).

